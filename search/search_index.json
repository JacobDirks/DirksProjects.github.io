{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Jacob Dirks Portfolio <p>Welcome to the project portfolio for Jacob Dirks. Projects will descend in order from most recent to previous projects. As for who I am? Well I'm a dual engineering student who has a love for all kinds of games. From computer games to soccer. I give back to the games I've played since childhood, as a soccer official for all ages from youth to semi professional amateur adult. I love the unique challenges which come from new projects and look forward to all the new challenges I have yet to find.</p> <ul> <li>\"Mechanical Clock (In Progress)\"</li> <li>\"EGR 304 Irrigation System\"</li> <li>\"EGR 102 Automatic Boom Leveling\"</li> <li>\"Useless Box\"</li> </ul>","tags":["tag1","tag2"]},{"location":"egr102/","title":"Automatic Boom Leveling","text":"","tags":["tag1","tag2"]},{"location":"egr102/#overview","title":"Overview","text":"<p>Take a need from the agricultural community, in specific regarding the growth or maintenance of crops, and for our group we chose an automatic boom leveling device. Since this is a school project it is important to note that I received permission to use this assignment here. One other piece of information that is important, this project was meant strictly to create a functional prototype and complete an elevator pitch.</p>","tags":["tag1","tag2"]},{"location":"egr102/#contribution","title":"Contribution","text":"<p>Within the team's composition I was in charge of working directly with the project head to ensure we stayed on top of deadlines and I was in charge of the code base. This involved leading the development of the code and researching how various sensors sent signals back to the controller and how to use those signals.</p> <pre><code>#include &lt;Servo.h&gt;\nServo boomHeight; // create servo object to control boom height\n\nint pos = 0; // variable for bottom of boom height\nint buttPin = 7;\ndouble goodLow = 3; // low end of acceptable boom height\ndouble goodHigh = 2.90; // high end of accpetable boom height\nvoid setup() {\n  // put your setup code here, to run once:\nSerial.begin(9600);\nboomHeight.attach(9); //attach servo to pin 9\nboomHeight.write(pos); // moves boom heigh to 0\n\n} \n\nvoid loop() {\n  // put your main code here, to run repeatedly:\n  int sensorValue = analogRead(A1); // gets value from IR sensors\n  float voltage = sensorValue * (5.0 / 1023.0); // measures the voltage\n // Serial.println(voltage);\nif((goodHigh &lt;= voltage) &amp;&amp;( goodLow &gt;= voltage)){Serial.println(voltage);}\nelse {\n  if(goodLow &lt;= voltage){ // alters position as long as this is true\n\n    if((pos &gt;= 0)&amp;&amp;(pos&lt;180)){\n      boomHeight.write(pos); // starts raising\n      delay(30); // gives it a second to move\n      pos=pos+1;\n    }\n\n  int sensorValue = analogRead(A1); // gets value from IR sensors\n  float voltage = sensorValue * (5.0 / 1023.0); // measures the voltage\n  Serial.println(voltage);\n  Serial.print(\"loop 1: \");\n  }\n  if(voltage &lt;= goodHigh) { // alters position as long as it is taller based on voltage return\n\n    if((pos &lt;= 180)&amp;&amp;(pos &gt; 0)){\n      boomHeight.write(pos); // starts lowering\n      delay(30); //gives it a second to move\n      pos = pos-1;\n    }\n    int sensorValue = analogRead(A1); // gets value from IR sensors\n  float voltage = sensorValue * (5.0 / 1023.0); // measures the voltage\n  Serial.print(\"loop 2: \");\n  Serial.println(voltage);\n  }\n  }\n}\n</code></pre>","tags":["tag1","tag2"]},{"location":"egr102/#results","title":"Results","text":"<p>We developed a working prototype that had room for improvement using another motor and another sensor.</p> <p>Lessons learned: Arduino: interactions with an IR sensor, develop with iterative hardware requirements, and record benchmark steps.</p>","tags":["tag1","tag2"]},{"location":"EGR304/egr304/","title":"Irrigation Project","text":"","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#overview","title":"Overview","text":"<p>The goal of this project was to find a need within the house that an everyday individual would find helpful if they didn't have to worry about it while working with a new team of individuals. Since this was a school based project the background idea as communicated by my professors was actually to mimic a little bit of the professional environment.</p> <p>In order to keep things brief the links to the project's website are Team website and Individual website. They are linked together but unfortunately I am not able to link them back to this one as it was submitted for a school assignment but I do have permission to share.</p>","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#contribution","title":"Contribution","text":"<p>Aside from the individual section which each team member was responsible for their own I also helped the team stay on track with our various assignments by measuring criteria against our rubrics and timelines. This included looking ahead to future assignments and reaching out to find vendors for parts at various points in the development cycle. Since I was also the only one with prior coding knowledge I took lead when it came to our communication protocol (binary signals) and general code based needs while aiming to support the development of my peers coding skills in C with an emphasis on embedded systems.</p>","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#results","title":"Results","text":"<p>Overall our team met the project requirements mentioned in the team website but did lose some points on our websites ability to communicate information effectively.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/","title":"Mechanical Clock","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#overview","title":"Overview","text":"<p>Create a several segment clock to learn communication protocols, print statement debugging, and wire management in a physical project.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#visuals","title":"Visuals","text":"<p>Are not yet ready as the project is in the barest of implementation stages.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#contribution","title":"Contribution","text":"<p>I briefly saw an image of a similar project and wanted to attempt to create everything from scratch. This has thus far been limited by my lack of understanding of communication protocols and rather than risk breaking electrical parts, I enrolled in classes that would teach those communication protocols. Otherwise I have designed the initial layout of the physical components and the code base to match.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#technical-details","title":"Technical Details","text":"<p>The current parts for the template are as follows:</p> <ul> <li>Clock segment or a servo mount</li> <li></li> <li>Clock Face</li> <li></li> <li>Corner link</li> <li></li> <li>Center links</li> <li></li> </ul> <p>As for files to print these parts look no further than this zip folder</p> Item Name Quantity Price Arduino Uno 1 $27.60 SG90 Micro Servo Motor 22 $41.20 PCA9685 16 Channel PWM Servo Motor Driver Board 2 $9.99 3D filament Unknown Unknown <p>Code Base:</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Keypad.h&gt;\n#include &lt;Adafruit_PWMServoDriver.h&gt;\n/*\nMade by Jacob Dirks\nDedicated hours spent: 7\nHalf-focused hours: 22 - I like watching movies and playing games while on summer break\nBuilt for: Personal Project\n*/\n\n/*\nTODO List: \nFigure out if we're adding light sources. Are those on a switch? - feature for an updated version\nCheck power draw\nFinally make edits for a finalized design per digit, Clean up wiring in that design, clean up code, and get mounting\n\n*/\n\n/*\n\n DIAGRAM\n   -         20             13          6\n-    22   18    19       11    12     4   5\n   -          17            10          3\n-    21    15    16       8     9     1   2\n   -          14             7          0\nhourTen   hourOne        minuteTen   minuteOne\n\n\n*/\n\n//section for button sensor it goes from pins 9 to pin 2-3 depending on if you want to connect the last row or not. Since the code doesn't use A-D my model doesn't have it connected\nconst byte ROWS = 4;\nconst byte COLS = 4; // if there are 3 columns update this\nchar hexaKeys[ROWS][COLS] = { // ABCD are later ignored so we could use a 3x4 instead of a 4x4\n  {'1', '2', '3', 'A'},\n  {'4', '5', '6', 'B'},\n  {'7', '8', '9', 'C'},\n  {'*', '0', '#', 'D'}\n};\n\nbyte rowPins[ROWS] = {9, 8, 7, 6}; \nbyte colPins[COLS] = {5, 4, 3, 2}; // for 3x4 remove \", 2\"\n\nKeypad customKeypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);\n\nAdafruit_PWMServoDriver driver = Adafruit_PWMServoDriver(0x40);\nAdafruit_PWMServoDriver driverTwo = Adafruit_PWMServoDriver(0x41);\n\n\n#define NUM_SERVOS 23\n#define SERVO_MIN 100               // SERVO_MIN and SERVO_MAX are based on pulse widths for positioning, other unit information is not generally provided. MIN = 100, MAX = 600 for my servos and values provided by spec sheet.\n#define SERVO_MAX 600               // signial to put them on the otherside but is currently unused\n#define SERVO_MID 350               // THIS IS DONE BY Max-Min MAY want to update it\n#define SERVO_DELAY 1000 // delay in milliseconds\n\nconst int SERVO_DRIVER_CAP = 16;\nint hourTen;\nint hourOne;\nint minuteOne;\nint minuteTen;\nunsigned long prevMilli; // useful for setting up clock while other items are still processing or delays are running\nunsigned long currMilli;\nunsigned long duration;\nunsigned long minuteTime = 60000;  // 60000ms in a minute used for consistent time changes\n\n\nbool minute = false;\n\n\nvoid setup(){\n  Serial.begin(9600);\nSerial.println(\"started\");\n  prevMilli = millis();\n  driver.begin();\n  driver.setPWMFreq(50);\n  delay(50);\nSerial.println(\"Driver initialized\");\n  // Initialzie all servos to their min position durving setup\n  for (int i = 0; i &lt; NUM_SERVOS; i++){\n\n    if (i &gt; SERVO_DRIVER_CAP){\n\n    driver.setPWM(i, 0, SERVO_MIN);\n\n    } else {\n\n      driverTwo.setPWM(i, 0, SERVO_MIN);\n\n    }\n\n  }\n\n  hourTen = 0; // I desire to initalize to 1:00\n  hourOne = 1;\n  minuteOne = 0;\n  minuteTen = 0;\n\n  // initialize the first position to 1:00\n  // as we are currently only working with 1 digit we will do the first 0 first.\nSerial.println(\"Starting clock\");\n setClock(100);\n delay(10);\n\n}\n\nvoid loop(){\n\n  currMilli = millis();\n  duration = currMilli-prevMilli; // systematically identify how long things have been running for TESTING\n  Serial.println(duration);\n  if (duration &gt; minuteTime){ // so that's every minute... what about when it flips on day 49.7?                                                     //REAL TIME ERROR  we crash at 60000 ms ... WHY?\n\n    // Ok research says that since they are unsigned longs this one line should TECHNICALLY handle the overflow\nSerial.println(\"We made it into the loop and you didn't mess up the math\");\n\n    changeTime();\n\n    }\n\n    char customKey = customKeypad.getKey();\n\n  if (customKey!= NO_KEY){\n\n    inputKeypad();\n\n  }\n\n  delay(100);\n\n}\n\nvoid inputKeypad(){\n\n  String futureTime = \"\";\n  char lastKeyPress = NO_KEY;\n  int desiredTime = 0;\n\n  while ((lastKeyPress != '*') || (lastKeyPress != '#')){ // while character inputed is not # or *  we can continue getting values;\n\n    if (lastKeyPress != NO_KEY){// check if its a letter, if not then add it to future time\n\n      switch (lastKeyPress){\n\n        case 'A':\n        case 'B':\n        case 'C':\n        case 'D': // 'A' 'B' 'C' and 'D' all end up doing the same thing resetting it NO_KEY and searching for a new input\n          lastKeyPress = NO_KEY;\n          break;\n\n        case '*':\n        case '#': // with * and # in case they somehow aren't picked up we want the system to recongnize it so we'll give a second chance\n          break;\n\n        default: // default is for 0-9 and will need input from hours first in tens then ones, then go minutes in tens then ones\n          futureTime += lastKeyPress;\n          lastKeyPress = NO_KEY;\n\n      /* //alternative case's for legibility\n\n        case 'A': // ignore current input and get new\n\n          lastKeyPress = NO_KEY\n          break;\n\n        case 'B': // ignore current input and get new\n\n          lastKeyPress = NO_KEY\n          break;\n\n        case 'C': // still not a valid input so we ignore it\n\n          lastKeyPress = NO_KEY\n          break;\n\n        case 'D': // also not valid\n\n          lastKeyPress = NO_KEY\n          break;\n\n        case '*': // with * and # in case they somehow aren't picked up we want the system to recongnize it so we'll give a second chance\n\n          break;\n\n        case '#': // should also be redundant\n\n          break;\n\n        default:  // default is for 0-9 and will need input from hours first in tens then ones, then go minutes in tens then ones\n\n          futureTime+= lastKeyPress;\n          lastKeyPress = NO_KEY;\n\n      */\n      }\n    }\n\n\n    if (futureTime.length() == 4){ // only 4 digits are allowed in the clock\n\n      break; // break out of the while loop chains and go to end commands which relate to sending the number to the clock\n\n    }\n\n    while (lastKeyPress == NO_KEY){\n\n      delay(10);\n      lastKeyPress = customKeypad.getKey();\n\n    }\n\n  }\n\n  desiredTime = futureTime.toInt(); // convert to an int\n  Serial.println(futureTime);                                                                                            // FOR TESTING\n  setClock(desiredTime);\n\n}\n\n\nvoid setClock(int num){ // When in combination with switch to set time.\n\n  //first lower all planes before we start worrying about the 3-4 digit number getting passed\n  closeSevenSegmentDigit(0);\n  closeSevenSegmentDigit(7);\n  closeSevenSegmentDigit(14);\n  closeTwoSegmentDigit(21);\n\nSerial.println(\"closed segments\");\n\n  int digit = num % 10; //isolate last digit- forced to be 0-9\n  num = num / 10; // prepare num for next section\n  setMinuteOne(digit); // send last digit to lowest place - repeat\n  digit = num % 10;\n  num = num / 10;\n  setMinuteTen(digit);\n  digit = num % 10;\n  num = num / 10;\n  setHourOne(digit);\n  setHourTen(num); // num should only be 1 place left and that should be a 1 or a 0. \n  prevMilli = currMilli;\n\n}\n\nvoid setHourTen(int desired){ // I uh don't know anymore why its a switch case other than unity between methods\n\n  switch(desired){\n\n    case 1:\n\n      moveNumUp(21);\n      moveNumUp(22);\n      hourTen = desired;\n\n  }\n\n}\n\nvoid setHourOne(int desired){// raises the individual planes one by one to represent each number for the ones place in the hour location\n\n    switch(desired){\n\n    case 0:\n\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(16);\n      moveNumUp(18);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n    case 1:\n\n      moveNumUp(16);\n      moveNumUp(19);\n      break;\n\n    case 2:\n\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(17);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n    case 3:\n\n      moveNumUp(14);\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n    case 4:\n\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(19);\n      break;\n\n    case 5:\n\n      moveNumUp(14);\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(20);\n      break;\n\n    case 6:\n\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(20);\n      break;\n\n    case 7:\n\n      moveNumUp(16);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n    case 8:\n\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n    case 9:\n\n      moveNumUp(14);\n      moveNumUp(16);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(19);\n      moveNumUp(20);\n      break;\n\n  }\n\n  hourOne = desired;\n\n}\n\nvoid setMinuteTen(int desired){// raises the individual planes one by one to represent each number for the tens place in the minute location\n\n    switch(desired){\n\n    case 0:\n\n      moveNumUp(7);\n      moveNumUp(8);\n      moveNumUp(9);\n      moveNumUp(11);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n\n    case 1:\n\n      moveNumUp(9);\n      moveNumUp(12);\n      break;\n\n    case 2:\n\n      moveNumUp(7);\n      moveNumUp(8);\n      moveNumUp(10);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n\n    case 3:\n\n      moveNumUp(7);\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n\n    case 4:\n\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(11);\n      moveNumUp(12);\n      break;\n\n    case 5:\n\n      moveNumUp(7);\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(11);\n      moveNumUp(13);\n      break;\n\n    case 6:\n\n      moveNumUp(7);\n      moveNumUp(8);\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(11);\n      moveNumUp(13);\n      break;\n\n    case 7:\n\n      moveNumUp(9);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n\n    case 8:\n\n      moveNumUp(7);\n      moveNumUp(8);\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(11);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n\n    case 9:\n\n      moveNumUp(7);\n      moveNumUp(9);\n      moveNumUp(10);\n      moveNumUp(11);\n      moveNumUp(12);\n      moveNumUp(13);\n      break;\n  }\n\n  minuteTen = desired; \n\n}\n\nvoid setMinuteOne(int desired){// raises the individual planes one by one to represent each number for the ones place in the minute location\n\n  switch(desired){\n\n    case 0:\n\n      moveNumUp(0);\n      moveNumUp(1);\n      moveNumUp(2);\n      moveNumUp(4);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n\n    case 1:\n\n      moveNumUp(2);\n      moveNumUp(5);\n      break;\n\n    case 2:\n\n      moveNumUp(0);\n      moveNumUp(1);\n      moveNumUp(3);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n\n    case 3:\n\n      moveNumUp(0);\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n\n    case 4:\n\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(4);\n      moveNumUp(5);\n      break;\n\n    case 5:\n\n      moveNumUp(0);\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(4);\n      moveNumUp(6);\n      break;\n\n    case 6:\n\n      moveNumUp(0);\n      moveNumUp(1);\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(4);\n      moveNumUp(6);\n      break;\n\n    case 7:\n\n      moveNumUp(2);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n\n    case 8:\n\n      moveNumUp(0);\n      moveNumUp(1);\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(4);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n\n    case 9:\n\n      moveNumUp(0);\n      moveNumUp(2);\n      moveNumUp(3);\n      moveNumUp(4);\n      moveNumUp(5);\n      moveNumUp(6);\n      break;\n  }\n\n  minuteOne = desired;\n\n}\n\nvoid closeSevenSegmentDigit(int startNum){ // Puts all of the segments in that area down. Only works on minutes and the ones position for the hours\n\n  for (int i = startNum; i&lt;(startNum+7); i++){\n\n    moveNumDown(i);\n\n  }\n\n  delay(10);\n\n}\n\nvoid closeTwoSegmentDigit(int startNum){ // lowers both segments of the hour section and potientially any other's that you want to lower 2 sections on\n\n  for (int i = startNum; i&lt;(startNum+2); i++){\n\n    moveNumDown(i);\n\n  }\n\n  delay(10);\n\n}\n\nvoid changeTime(){ // assumptions = increase hour will tell if we need to increase the tens place as well and if we need to reset it to 1. Increase Minute will handle both 10s and 1s\n\n  if (minuteOne == 9){\n\n    incMinuteOne(0); // set's 1's place to 0\n\n    if (minuteTen == 5){ // logic for incrementing 10's place\n\n      increaseHour();\n      incMinuteTen(0);\n\n    } else {\n\n    incMinuteTen(minuteTen+1);\n\n    }\n\n  } else {\n\n    incMinuteOne(minuteOne + 1);\n\n  }\n\n  prevMilli = currMilli - (currMilli % minuteTime); // this updates the minute changes without losing seconds\n  Serial.println(prevMilli);\n  Serial.print(\"Minute One: \");\n  Serial.println(minuteOne);\n}\n\nvoid increaseHour(){\n\n  if (hourTen==1){ // edge case of 12:59 increment\n\n    if (hourOne == 2){\n\n      incHourTen(0);\n      incHourOne(12); // specialized edge case\n\n    }\n\n  } else if (hourOne ==9){ //go to 10:00 \n\n    incHourTen(1);\n    incHourOne(0);\n\n  }  else {\n\n    incHourOne(hourOne + 1); // standard increment\n\n  }\n\n}\n\n\nvoid incHourTen(int desired){ \n\n  switch(desired){\n\n    case 1:\n\n      //switch from 0 to 1\n      moveNumUp(21);\n      moveNumUp(22);\n      break;\n\n    case 0:\n\n      //switch from 1 to 0\n      moveNumDown(21);\n      moveNumDown(22);\n      break;\n\n  }\n\n  hourTen = desired;\n\n}\n\nvoid incHourOne(int desired){ // this one is needed to go from 12 back to 01\n\n  switch(desired){\n\n    case 0: // 9 to 0\n\n      moveNumDown(17);\n      moveNumUp(15);\n      incHourTen(1);\n      break;\n\n    case 1: // 0 to 1\n\n      moveNumDown(14);\n      moveNumDown(15);\n      moveNumDown(17);\n      moveNumDown(18);\n      moveNumDown(20);\n      break;\n\n    case 2: // 1 to 2\n\n      moveNumDown(16);\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(17);\n      moveNumUp(20);\n      break;\n\n    case 3: // 2 to 3\n\n      moveNumDown(15);\n      moveNumUp(16);\n      break;\n\n    case 4: // 3 to 4\n\n      moveNumDown(14);\n      moveNumDown(20);\n      moveNumUp(18);\n      break;\n\n    case 5:  // 4 to 5\n\n      moveNumDown(19);\n      moveNumUp(14);\n      moveNumUp(17);\n      moveNumUp(18);\n      moveNumUp(20);\n      break;\n\n    case 6:  // 5 to 6\n\n      moveNumUp(15);\n      break;\n\n    case 7:  // 6 to 7\n\n      moveNumDown(14);\n      moveNumDown(15);\n      moveNumDown(17);\n      moveNumDown(18);\n      moveNumUp(19);\n      break;\n\n    case 8: // 7 to 8\n\n      moveNumUp(14);\n      moveNumUp(15);\n      moveNumUp(17);\n      moveNumUp(18);\n      break;\n\n    case 9: // 8 to 9\n\n      moveNumDown(15);\n      break;\n\n    case 12: // 2 to 1 for 12 to 01 edge case\n\n      moveNumDown(0);\n      moveNumDown(1);\n      moveNumDown(3);\n      moveNumDown(6);\n      moveNumUp(2);\n      break;\n\n  }\n\n  hourOne = desired;\n\n}\n\nvoid incMinuteTen(int desired){\n\n  switch(desired){\n\n    case 1: // 0 to 1\n\n      moveNumDown(7);\n      moveNumDown(8);\n      moveNumDown(10);\n      moveNumDown(11);\n      moveNumDown(13);\n      break;\n\n    case 2: // 1 to 2\n\n      moveNumDown(9);\n      moveNumUp(7);\n      moveNumUp(8);\n      moveNumUp(10);\n      moveNumUp(13);\n      break;\n\n    case 3: // 2 to 3\n\n      moveNumDown(8);\n      moveNumUp(9);\n      break;\n\n    case 4: // 3 to 4\n\n      moveNumDown(7);\n      moveNumDown(13);\n      moveNumUp(11);\n      break;\n\n    case 5: // 4 to 5\n\n      moveNumDown(12);\n      moveNumUp(7);\n      moveNumUp(13);\n      break;\n\n    case 0: // 5 to 0\n\n      moveNumDown(10);\n      moveNumUp(8);\n      moveNumUp(12);\n      break;\n\n  }\n\n  minuteTen = desired;\n\n}\n\nvoid incMinuteOne(int desired){\n\n  switch(desired){                                                                                            //WORRY about Case 1?????\n\n    case 1:\n\n      // change 0 to 1\n      moveNumDown(0);\n      moveNumDown(1);\n      moveNumDown(3);\n      moveNumDown(4);\n      moveNumDown(6);\n      break;\n\n    case 2:\n\n      //change 1 to 2 \n      moveNumDown(2);\n      moveNumUp(1);\n      moveNumUp(6);\n      moveNumUp(3);\n      moveNumUp(0);\n      break;\n\n    case 3:\n\n      // change 2 to 3\n      moveNumDown(1);\n      moveNumUp(2);\n      break;\n\n    case 4:\n\n      //change 3 to 4\n      moveNumDown(6);\n      moveNumDown(0);\n      moveNumUp(4);\n      break;\n\n    case 5:\n\n      //change 4 to 5\n      moveNumDown(5);\n      moveNumUp(6);\n      moveNumUp(0);\n      break;\n\n    case 6:\n\n      // change 5 to 6\n      moveNumUp(1);\n      break;\n\n    case 7:\n\n      // change 6 to 7\n      moveNumDown(0);\n      moveNumDown(1);\n      moveNumDown(3);\n      moveNumDown(4);\n      moveNumUp(2);\n      moveNumUp(5);\n      break;\n\n    case 8:\n\n      // change 7 to 8\n      moveNumUp(4);\n      moveNumUp(3);\n      moveNumUp(1);\n      moveNumUp(0);\n      break;\n\n    case 9:\n\n      // change 8 to 9\n      moveNumDown(1);\n      moveNumDown(0);\n      break;\n\n    case 0:\n\n      //change 9 to 0\n      moveNumDown(3);\n      moveNumUp(1);\n      moveNumUp(0);\n      setMinuteTen(minuteTen++);\n      break;\n\n    }\n\n    minuteOne = desired; \n\n}\n\n\n\n// This section is not to be manipulated past testing. It functions as intended and will safely raise and lower bars\n\n// Num means its connected to the servo controller\n// Pin means its directly connected to the servo controller. \nvoid moveNumUp(int servoNum){\n\n  if (servoNum &gt; SERVO_DRIVER_CAP){\n\n    for (int pos = SERVO_MIN; pos&lt;=SERVO_MID; pos++){\n\n        driver.setPWM(servoNum, 0, pos);\n        delay(5);\n\n    }\n\n    delay(10);\n    driver.setPWM(servoNum,0, SERVO_MID);\n\n  } else {\n\n    for (int pos = SERVO_MIN; pos&lt;=SERVO_MID; pos++){\n\n      driverTwo.setPWM(servoNum, 0, pos);\n      delay(5);\n\n    }\n\n    delay(10);\n    driverTwo.setPWM(servoNum,0, SERVO_MID);\n\n  }\n\n}\n\nvoid moveNumDown(int servoNum){\n\n  if (servoNum &gt; SERVO_DRIVER_CAP){\n\n    for (int pos = SERVO_MID; pos&gt;=SERVO_MIN; pos--){\n\n      driver.setPWM(servoNum, 0, pos);\n      delay(5);\n\n    }\n\n    delay(10);\n    driver.setPWM(servoNum,0, SERVO_MIN);\n\n  } else {\n\n    for (int pos = SERVO_MID; pos&gt;=SERVO_MIN; pos--){\n\n      driverTwo.setPWM(servoNum, 0, pos);\n      delay(5);\n\n    }\n\n    delay(10);\n    driverTwo.setPWM(servoNum,0, SERVO_MIN);\n\n  }\n\n}\n</code></pre>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#results","title":"Results","text":"<p>This project is currently not complete so we have not achieved all of the goals of the project.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/","title":"Useless Box","text":"","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#overview","title":"Overview","text":"<p>Create a project to learn the basics of a pull up switch and motor using Arduino while ensuring the design is simple and replication is easy. If the goal is to view the project components please look at the Bill of Materials under the technical section and download the 3D printing files and the code base.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#contribution","title":"Contribution","text":"<p>This was an individual project which allowed me to work through all aspects of the project from initial conception to testing to final completion.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#technical-details","title":"Technical Details","text":"<p> All length units are in millimeters and angle units are in degrees.</p> Item Name Quantity Price Arduino Uno 1 $27.60 3D print filament 187.74 grams ~$3.20 Servo Futaba S3003 1 $6.25 3 position switch 1 $0.67 Copper wires 1 $3.67 <p>Code Base:</p> <pre><code>#include &lt;Servo.h&gt;\nServo ctrlArm; // create servo object to control a servo\n\n// Hours spent refactoring: .75 \n// Version 1.1\n// Created by Jacob Dirks\n\n// two of twelve ' board limit' reached'\n\nint pos = 0; // variable to control ctrl arm position\nint altCount = 0;\nint shortHeight = 150; // What is this\nint count = 1; // this is what we'll use for the random case generator. Makes it easier to store number\nint caseCount = 5; // easier to update later\nint runCount = 0;\nint moveBox = 3; // stores number 3 for pin 3\nint TState = 0; //variable for storing switch status\nint TStatePrior = TState; // stores previous state\n\nvoid setup() {\n  // put your setup code here, to run once:\n  ctrlArm.attach(13);\n  pinMode(moveBox, INPUT_PULLUP); // sets it as a special kind of input which is how the lever requires it\n\n  ctrlArm.write(pos); // gives it the first desire to go there\n  delay(100);\n  ctrlArm.write(pos); // allows the time to get there or is this what causes the initial open and close\n  delay(50);\n\n}\n\nvoid loop() {\n\n// section to open and move the box\nTState = digitalRead(moveBox); // reads state of switch\n\nif((TState == 1) &amp;&amp; (TStatePrior == 0)) { // changes the arm to replace it\n    if(pos != 170){\n      count = ((int)random(1, 2*caseCount) % caseCount);\n\n      switch(count){\n          case 0: // fast bounces cause angry\n\n              for(runCount=0; runCount&lt;=7; runCount += 1){\n\n                for(pos = 20; pos &lt;=45 ; pos+= 5){\n\n              ctrlArm.write(pos);\n              delay(10); // waits 10ms for the servo to reach the position\n\n              }\n                for(pos=45; pos&gt;=20; pos-=1){\n                  ctrlArm.write(pos);\n                  delay(15);\n                }\n              } \n\n              delay(20);\n\n              closeLidSpeed(15);\n              break;\n          case 2: // just close the lid\n            closeLidSpeed(15);\n            delay(20);\n            break;\n\n          case 3:/* a slow and then come back only to go out and hold it down again */\n\n            closeLidSpeed(25);\n            delay(30);\n            closeLidSpeed(25);\n            delay(180);\n            break;\n\n          case 4: // slow but up down a few times\n            closeLidSpeed(20);\n\n            for(runCount=0; runCount &lt; 2; runCount+= 1){\n\n              for(pos=20; pos&lt;=80; pos+= 2){\n\n                ctrlArm.write(pos);\n                delay(15);\n\n              }\n\n              for(pos=80; pos &gt;=20; pos-= 2){\n\n                ctrlArm.write(pos);\n                delay(15);\n\n              }\n\n            }\n\n            closeLidSpeed(15);\n\n          default:\n\n           closeLidSpeed(30);\n            break;\n        }\n      }\n\n        //here is the common code\n\n      TStatePrior = TState; // stores previous Tstate\n      TState = digitalRead(moveBox); // updates TState\n    } //end if of tstate = 1 and prior = 0\ndelay(250);\n  if((TState == 0) &amp;&amp; (TStatePrior ==1)) {\n\n  if(pos != 20){ // if not at home then return there\n  for (pos = 170; pos &gt;= 20; pos -= 10) { // goes from 170 degrees to 20 degrees \n\n    ctrlArm.write(pos); // tell servo to go to position in variable 'pos'\n    delay(15); // waits 15ms for the servo to reach the position\n\n  }\n  }\n  TState = digitalRead(moveBox);\nTStatePrior = 0;\n\n} else {\n  delay(250);\n  TState = digitalRead(moveBox);\n}\n\n} \n\nvoid closeLidSpeed(int speed){ // a method to simply flip the switch back with a delay choice\n  for (pos = 20; pos&lt;= 170; pos+=10){\n    ctrlArm.write(pos);\n    delay(speed); // wait 15 ms and then move it\n  }\n  ctrlArm.write(170);\n  pos = 170;\n}\n</code></pre>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#results","title":"Results","text":"<p>I was able to successfully build, test, and improve the useless box. Although there were several complications along the way regarding CAD software, signal reading, and physical manipulations.</p> System/Software Lessons Learned Solidworks Planes on an object, extrusion about an axis, print in place features, and tolerance printing Arduino Importance of simplifying complex sections in code, highlighting reusable parts, and the blessings of commented code <p>Future improvements: Reduce the footprint of the box, optimize port usage versus numbers, and add more reactions for the switch.</p>","tags":["tag1","tag2"]}]}