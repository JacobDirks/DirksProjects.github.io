{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Jacob Dirks Portfolio <p>Welcome to the project portfolio for Jacob Dirks. Projects will descend in order from most recent to previous projects.</p> <ul> <li>\"Mechanical Clock (In Progress)\"</li> <li>\"EGR 304 Irrigation System\"</li> <li>\"EGR 102 Automatic Boom Leveling\"</li> <li>\"Useless Box\"</li> </ul>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/","title":"Individual Block Diagram","text":"","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#overview","title":"Overview","text":"<p>This block diagram is part of a larger machine but still is able to work on its own to measure moisture. Two power levels are required which can be derived from the same 9v 3a power supply. This can supply power to both the motor at 12v levels (combined at the H-Bridge #FAN8100N) and the second power level is a 5v 1a which is obtained through the Voltage regulator (#L7805CV). This allows the Curiosity Nano to function at its desired power levels. This also enables sensing from the two limit switches (463093691402) and the capacitive sensor due to their operating ranges. Finally the h-Bridge, part number aforementioned, controls the motor (711) which will help keep the capacitive sensor safe when not actively reading values. Otherwise Pins that are being utilized help the curiosity nano communicate with the central hub nano for this team project.</p> <p>Parts List for sensors and actuators that are involved in the diagram. Are available as a list here and with all the other options in Component Selection. For the final choices and the amounts please visit the \"BOM\" section of the datasheet.</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#individual-block-diagram","title":"Individual Block Diagram","text":"","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#project-verification","title":"Project Verification","text":"<p>This project has a number of requirements for both the team and the individual in order to be marked as a success.</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#individual-subsystem-requirements","title":"Individual Subsystem Requirements","text":"<ul> <li>A 5V Linear Regulator</li> <li>Barrel Jack adapter for your 9V power supply</li> <li>A pre-selected microcontroller: a Microchip PIC18F57Q43 Curiosity Nano Development Board</li> <li>At least one distinct sensing or actuation functionality (four functionalities would be required across a four-person team)</li> <li>While individual modules are expected to have either sensing or actuation functionality as a minimum, there is an expectation that a mix of both sensing and actuation functionalities will be present when all the team modules are connected together.</li> <li>It is not permitted to replicate subsystem functionality within a team, or copy a classmate's design. Subsystems must be materially different, using different chips, design processes, and accomplishing different functions.</li> <li>Individual subsystems are required to connect to teammates' boards using the connector listed above. It is up to the team to determine what information to pass and to whom, but individuals will be required to demonstrate basic connectivity and data passing capabilities before being able to connect their device to their team's connectors.</li> </ul> <p>These traits can be seen in the block diagram for the individual subsection. On the bottom right of the block diagram we can see the 9V 3A Power supply which connects with the second bullet point. The barrel jack isn't placed on the block diagram as a block because that is a lower level detail that is covered by the higher details of voltage and amperage. Moving up directly from there we can find the 5V 1.5A voltage regulator and this part is a linear voltage regulator completing the first bullet point of requirements. This helps ensure that we have the correct level of power for the pre-selected microcontroller (top left to top center). In the case of this subsystem we have a distinct moisture sensing component which combines information in the other subsystems to tell the main controller whether or not to turn on a pump. Secondarily to ensure we meet sensing/actuation requirements the block diagram shows a motor as well as limit switches. These limit switches help control the range the motor operates in so that the motor can operate in a safe manner in relation to the moisture sensor. Finally returning to the bottom but this time on the left we can see the 8 pin connector used to communicate in between boards. Allowing for the final requirement to be seen through the jumper pin array as well as the direct connections to the micro controller.</p>","tags":["tag1","tag2"]},{"location":"01-Block-Diagram/Block-Diagram/#additional-file-types","title":"Additional File Types","text":"<p>This block diagram is available on as a draw io file and it can be found in pdf form here and finally the combined files can be found \"as a zip file.\"</p>","tags":["tag1","tag2"]},{"location":"EGR102/egr102/","title":"Automatic Boom Leveling","text":"","tags":["tag1","tag2"]},{"location":"EGR102/egr102/#overview","title":"Overview","text":"","tags":["tag1","tag2"]},{"location":"EGR102/egr102/#visuals","title":"Visuals","text":"","tags":["tag1","tag2"]},{"location":"EGR102/egr102/#contribution","title":"Contribution","text":"","tags":["tag1","tag2"]},{"location":"EGR102/egr102/#technical-details","title":"Technical Details","text":"","tags":["tag1","tag2"]},{"location":"EGR102/egr102/#results","title":"Results","text":"","tags":["tag1","tag2"]},{"location":"EGR304/egr304/","title":"Irrigation Project","text":"","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#overview","title":"Overview","text":"<p>The goal of this project was to find a need within the house that an everyday individual would find helpful if they didn't have to worry about it while working with a new team of individuals. Since this was a school based project the background idea as communicated by my professors was actually to mimic a little bit of the professional environment.</p> <p>In order to keep things brief the links to the project's website are Team website and Individual website. They are linked together but unfortunately I am not able to link them back to this one as it was submitted for a school assignment but I do have permission to share.</p>","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#contribution","title":"Contribution","text":"<p>Aside from the individual section which each team member was responsible for their own I also helped the team stay on track with our various assignments by measuring criteria against our rubrics and timelines. This included looking ahead to future assignments and reaching out to find vendors for parts at various points in the development cycle. Since I was also the only one with prior coding knowledge I took lead when it came to our communication protocol (binary signals) and general code based needs while aiming to support the development of my peers coding skills in C with an emphasis on embedded systems.</p>","tags":["tag1","tag2"]},{"location":"EGR304/egr304/#results","title":"Results","text":"<p>Overall our team met the project requirements mentioned in the team website but did lose some points on our websites ability to communicate information effectively.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/","title":"Mechanical Clock","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#overview","title":"Overview","text":"<p>Create a several segment clock to learn communication protocols, print statement debugging, and wire management in a physical project.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#visuals","title":"Visuals","text":"<p>Are not yet ready as the project is in the barest of implementation stages.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#contribution","title":"Contribution","text":"<p>I briefly saw an image of a similar project and wanted to attempt to create everything from scratch. This has thus far been limited by my lack of understanding of communication protocols and rather than risk breaking electrical parts, I enrolled in classes that would teach those communication protocols. Otherwise I have designed the initial layout of the physical components and the code base to match.</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#technical-details","title":"Technical Details","text":"<p>The current parts for the template are as follows:</p> <ul> <li>Clock segment or a servo mount</li> <li></li> <li>Clock Face</li> <li></li> <li>Corner link</li> <li></li> <li>Center links</li> <li></li> </ul> <p>As for files to print these parts look no further than this zip folder</p> Item Name Quantity Price Arduino Uno 1 $27.60 SG90 Micro Servo Motor 22 $41.20 PCA9685 16 Channel PWM Servo Motor Driver Board 2 $9.99 3D filament Unknown Unknown <p>Code Base:</p> <p>```Arduino { style=\"--md-codeblock-height: 100px;\" }</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#include","title":"include","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#include_1","title":"include","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#include_2","title":"include","text":"<p>/ Made by Jacob Dirks Dedicated hours spent: 7 Half-focused hours: 22 - I like watching movies and playing games while on summer break Built for: Personal Project /</p> <p>/* TODO List:  Figure out if we're adding light sources. Are those on a switch? - feature for an updated version Check power draw Finally make edits for a finalized design per digit, Clean up wiring in that design, clean up code, and get mounting</p> <p>*/</p> <p>/*</p> <p>DIAGRAM    -         20             13          6 -    22   18    19       11    12     4   5    -          17            10          3 -    21    15    16       8     9     1   2    -          14             7          0 hourTen   hourOne        minuteTen   minuteOne</p> <p>*/</p> <p>//section for button sensor it goes from pins 9 to pin 2-3 depending on if you want to connect the last row or not. Since the code doesn't use A-D my model doesn't have it connected const byte ROWS = 4; const byte COLS = 4; // if there are 3 columns update this char hexaKeys[ROWS][COLS] = { // ABCD are later ignored so we could use a 3x4 instead of a 4x4   {'1', '2', '3', 'A'},   {'4', '5', '6', 'B'},   {'7', '8', '9', 'C'},   {'*', '0', '#', 'D'} };</p> <p>byte rowPins[ROWS] = {9, 8, 7, 6};  byte colPins[COLS] = {5, 4, 3, 2}; // for 3x4 remove \", 2\"</p> <p>Keypad customKeypad = Keypad(makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS);</p> <p>Adafruit_PWMServoDriver driver = Adafruit_PWMServoDriver(0x40); Adafruit_PWMServoDriver driverTwo = Adafruit_PWMServoDriver(0x41);</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#define-num_servos-23","title":"define NUM_SERVOS 23","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#define-servo_min-100-servo_min-and-servo_max-are-based-on-pulse-widths-for-positioning-other-unit-information-is-not-generally-provided-min-100-max-600-for-my-servos-and-values-provided-by-spec-sheet","title":"define SERVO_MIN 100               // SERVO_MIN and SERVO_MAX are based on pulse widths for positioning, other unit information is not generally provided. MIN = 100, MAX = 600 for my servos and values provided by spec sheet.","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#define-servo_max-600-signial-to-put-them-on-the-otherside-but-is-currently-unused","title":"define SERVO_MAX 600               // signial to put them on the otherside but is currently unused","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#define-servo_mid-350-this-is-done-by-max-min-may-want-to-update-it","title":"define SERVO_MID 350               // THIS IS DONE BY Max-Min MAY want to update it","text":"","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#define-servo_delay-1000-delay-in-milliseconds","title":"define SERVO_DELAY 1000 // delay in milliseconds","text":"<p>const int SERVO_DRIVER_CAP = 16; int hourTen; int hourOne; int minuteOne; int minuteTen; unsigned long prevMilli; // useful for setting up clock while other items are still processing or delays are running unsigned long currMilli; unsigned long duration; unsigned long minuteTime = 60000;  // 60000ms in a minute used for consistent time changes</p> <p>bool minute = false;</p> <p>void setup(){   Serial.begin(9600); Serial.println(\"started\");   prevMilli = millis();   driver.begin();   driver.setPWMFreq(50);   delay(50); Serial.println(\"Driver initialized\");   // Initialzie all servos to their min position durving setup   for (int i = 0; i &lt; NUM_SERVOS; i++){</p> <pre><code>if (i &gt; SERVO_DRIVER_CAP){\n\ndriver.setPWM(i, 0, SERVO_MIN);\n\n} else {\n\n  driverTwo.setPWM(i, 0, SERVO_MIN);\n\n}\n</code></pre> <p>}</p> <p>hourTen = 0; // I desire to initalize to 1:00   hourOne = 1;   minuteOne = 0;   minuteTen = 0;</p> <p>// initialize the first position to 1:00   // as we are currently only working with 1 digit we will do the first 0 first. Serial.println(\"Starting clock\");  setClock(100);  delay(10);</p> <p>}</p> <p>void loop(){</p> <p>currMilli = millis();   duration = currMilli-prevMilli; // systematically identify how long things have been running for TESTING   Serial.println(duration);   if (duration &gt; minuteTime){ // so that's every minute... what about when it flips on day 49.7?                                                     //REAL TIME ERROR  we crash at 60000 ms ... WHY?</p> <pre><code>// Ok research says that since they are unsigned longs this one line should TECHNICALLY handle the overflow\n</code></pre> <p>Serial.println(\"We made it into the loop and you didn't mess up the math\");</p> <pre><code>changeTime();\n\n}\n\nchar customKey = customKeypad.getKey();\n</code></pre> <p>if (customKey!= NO_KEY){</p> <pre><code>inputKeypad();\n</code></pre> <p>}</p> <p>delay(100);</p> <p>}</p> <p>void inputKeypad(){</p> <p>String futureTime = \"\";   char lastKeyPress = NO_KEY;   int desiredTime = 0;</p> <p>while ((lastKeyPress != '*') || (lastKeyPress != '#')){ // while character inputed is not # or *  we can continue getting values;</p> <pre><code>if (lastKeyPress != NO_KEY){// check if its a letter, if not then add it to future time\n\n  switch (lastKeyPress){\n\n    case 'A':\n    case 'B':\n    case 'C':\n    case 'D': // 'A' 'B' 'C' and 'D' all end up doing the same thing resetting it NO_KEY and searching for a new input\n      lastKeyPress = NO_KEY;\n      break;\n\n    case '*':\n    case '#': // with * and # in case they somehow aren't picked up we want the system to recongnize it so we'll give a second chance\n      break;\n\n    default: // default is for 0-9 and will need input from hours first in tens then ones, then go minutes in tens then ones\n      futureTime += lastKeyPress;\n      lastKeyPress = NO_KEY;\n\n  /* //alternative case's for legibility\n\n    case 'A': // ignore current input and get new\n\n      lastKeyPress = NO_KEY\n      break;\n\n    case 'B': // ignore current input and get new\n\n      lastKeyPress = NO_KEY\n      break;\n\n    case 'C': // still not a valid input so we ignore it\n\n      lastKeyPress = NO_KEY\n      break;\n\n    case 'D': // also not valid\n\n      lastKeyPress = NO_KEY\n      break;\n\n    case '*': // with * and # in case they somehow aren't picked up we want the system to recongnize it so we'll give a second chance\n\n      break;\n\n    case '#': // should also be redundant\n\n      break;\n\n    default:  // default is for 0-9 and will need input from hours first in tens then ones, then go minutes in tens then ones\n\n      futureTime+= lastKeyPress;\n      lastKeyPress = NO_KEY;\n\n  */\n  }\n}\n\n\nif (futureTime.length() == 4){ // only 4 digits are allowed in the clock\n\n  break; // break out of the while loop chains and go to end commands which relate to sending the number to the clock\n\n}\n\nwhile (lastKeyPress == NO_KEY){\n\n  delay(10);\n  lastKeyPress = customKeypad.getKey();\n\n}\n</code></pre> <p>}</p> <p>desiredTime = futureTime.toInt(); // convert to an int   Serial.println(futureTime);                                                                                            // FOR TESTING   setClock(desiredTime);</p> <p>}</p> <p>void setClock(int num){ // When in combination with switch to set time.</p> <p>//first lower all planes before we start worrying about the 3-4 digit number getting passed   closeSevenSegmentDigit(0);   closeSevenSegmentDigit(7);   closeSevenSegmentDigit(14);   closeTwoSegmentDigit(21);</p> <p>Serial.println(\"closed segments\");</p> <p>int digit = num % 10; //isolate last digit- forced to be 0-9   num = num / 10; // prepare num for next section   setMinuteOne(digit); // send last digit to lowest place - repeat   digit = num % 10;   num = num / 10;   setMinuteTen(digit);   digit = num % 10;   num = num / 10;   setHourOne(digit);   setHourTen(num); // num should only be 1 place left and that should be a 1 or a 0.    prevMilli = currMilli;</p> <p>}</p> <p>void setHourTen(int desired){ // I uh don't know anymore why its a switch case other than unity between methods</p> <p>switch(desired){</p> <pre><code>case 1:\n\n  moveNumUp(21);\n  moveNumUp(22);\n  hourTen = desired;\n</code></pre> <p>}</p> <p>}</p> <p>void setHourOne(int desired){// raises the individual planes one by one to represent each number for the ones place in the hour location</p> <pre><code>switch(desired){\n\ncase 0:\n\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(16);\n  moveNumUp(18);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n\ncase 1:\n\n  moveNumUp(16);\n  moveNumUp(19);\n  break;\n\ncase 2:\n\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(17);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n\ncase 3:\n\n  moveNumUp(14);\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n\ncase 4:\n\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(19);\n  break;\n\ncase 5:\n\n  moveNumUp(14);\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(20);\n  break;\n\ncase 6:\n\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(20);\n  break;\n\ncase 7:\n\n  moveNumUp(16);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n\ncase 8:\n\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n\ncase 9:\n\n  moveNumUp(14);\n  moveNumUp(16);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(19);\n  moveNumUp(20);\n  break;\n</code></pre> <p>}</p> <p>hourOne = desired;</p> <p>}</p> <p>void setMinuteTen(int desired){// raises the individual planes one by one to represent each number for the tens place in the minute location</p> <pre><code>switch(desired){\n\ncase 0:\n\n  moveNumUp(7);\n  moveNumUp(8);\n  moveNumUp(9);\n  moveNumUp(11);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n\ncase 1:\n\n  moveNumUp(9);\n  moveNumUp(12);\n  break;\n\ncase 2:\n\n  moveNumUp(7);\n  moveNumUp(8);\n  moveNumUp(10);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n\ncase 3:\n\n  moveNumUp(7);\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n\ncase 4:\n\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(11);\n  moveNumUp(12);\n  break;\n\ncase 5:\n\n  moveNumUp(7);\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(11);\n  moveNumUp(13);\n  break;\n\ncase 6:\n\n  moveNumUp(7);\n  moveNumUp(8);\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(11);\n  moveNumUp(13);\n  break;\n\ncase 7:\n\n  moveNumUp(9);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n\ncase 8:\n\n  moveNumUp(7);\n  moveNumUp(8);\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(11);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n\ncase 9:\n\n  moveNumUp(7);\n  moveNumUp(9);\n  moveNumUp(10);\n  moveNumUp(11);\n  moveNumUp(12);\n  moveNumUp(13);\n  break;\n</code></pre> <p>}</p> <p>minuteTen = desired; </p> <p>}</p> <p>void setMinuteOne(int desired){// raises the individual planes one by one to represent each number for the ones place in the minute location</p> <p>switch(desired){</p> <pre><code>case 0:\n\n  moveNumUp(0);\n  moveNumUp(1);\n  moveNumUp(2);\n  moveNumUp(4);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n\ncase 1:\n\n  moveNumUp(2);\n  moveNumUp(5);\n  break;\n\ncase 2:\n\n  moveNumUp(0);\n  moveNumUp(1);\n  moveNumUp(3);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n\ncase 3:\n\n  moveNumUp(0);\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n\ncase 4:\n\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(4);\n  moveNumUp(5);\n  break;\n\ncase 5:\n\n  moveNumUp(0);\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(4);\n  moveNumUp(6);\n  break;\n\ncase 6:\n\n  moveNumUp(0);\n  moveNumUp(1);\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(4);\n  moveNumUp(6);\n  break;\n\ncase 7:\n\n  moveNumUp(2);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n\ncase 8:\n\n  moveNumUp(0);\n  moveNumUp(1);\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(4);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n\ncase 9:\n\n  moveNumUp(0);\n  moveNumUp(2);\n  moveNumUp(3);\n  moveNumUp(4);\n  moveNumUp(5);\n  moveNumUp(6);\n  break;\n</code></pre> <p>}</p> <p>minuteOne = desired;</p> <p>}</p> <p>void closeSevenSegmentDigit(int startNum){ // Puts all of the segments in that area down. Only works on minutes and the ones position for the hours</p> <p>for (int i = startNum; i&lt;(startNum+7); i++){</p> <pre><code>moveNumDown(i);\n</code></pre> <p>}</p> <p>delay(10);</p> <p>}</p> <p>void closeTwoSegmentDigit(int startNum){ // lowers both segments of the hour section and potientially any other's that you want to lower 2 sections on</p> <p>for (int i = startNum; i&lt;(startNum+2); i++){</p> <pre><code>moveNumDown(i);\n</code></pre> <p>}</p> <p>delay(10);</p> <p>}</p> <p>void changeTime(){ // assumptions = increase hour will tell if we need to increase the tens place as well and if we need to reset it to 1. Increase Minute will handle both 10s and 1s</p> <p>if (minuteOne == 9){</p> <pre><code>incMinuteOne(0); // set's 1's place to 0\n\nif (minuteTen == 5){ // logic for incrementing 10's place\n\n  increaseHour();\n  incMinuteTen(0);\n\n} else {\n\nincMinuteTen(minuteTen+1);\n\n}\n</code></pre> <p>} else {</p> <pre><code>incMinuteOne(minuteOne + 1);\n</code></pre> <p>}</p> <p>prevMilli = currMilli - (currMilli % minuteTime); // this updates the minute changes without losing seconds   Serial.println(prevMilli);   Serial.print(\"Minute One: \");   Serial.println(minuteOne); }</p> <p>void increaseHour(){</p> <p>if (hourTen==1){ // edge case of 12:59 increment</p> <pre><code>if (hourOne == 2){\n\n  incHourTen(0);\n  incHourOne(12); // specialized edge case\n\n}\n</code></pre> <p>} else if (hourOne ==9){ //go to 10:00 </p> <pre><code>incHourTen(1);\nincHourOne(0);\n</code></pre> <p>}  else {</p> <pre><code>incHourOne(hourOne + 1); // standard increment\n</code></pre> <p>}</p> <p>}</p> <p>void incHourTen(int desired){ </p> <p>switch(desired){</p> <pre><code>case 1:\n\n  //switch from 0 to 1\n  moveNumUp(21);\n  moveNumUp(22);\n  break;\n\ncase 0:\n\n  //switch from 1 to 0\n  moveNumDown(21);\n  moveNumDown(22);\n  break;\n</code></pre> <p>}</p> <p>hourTen = desired;</p> <p>}</p> <p>void incHourOne(int desired){ // this one is needed to go from 12 back to 01</p> <p>switch(desired){</p> <pre><code>case 0: // 9 to 0\n\n  moveNumDown(17);\n  moveNumUp(15);\n  incHourTen(1);\n  break;\n\ncase 1: // 0 to 1\n\n  moveNumDown(14);\n  moveNumDown(15);\n  moveNumDown(17);\n  moveNumDown(18);\n  moveNumDown(20);\n  break;\n\ncase 2: // 1 to 2\n\n  moveNumDown(16);\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(17);\n  moveNumUp(20);\n  break;\n\ncase 3: // 2 to 3\n\n  moveNumDown(15);\n  moveNumUp(16);\n  break;\n\ncase 4: // 3 to 4\n\n  moveNumDown(14);\n  moveNumDown(20);\n  moveNumUp(18);\n  break;\n\ncase 5:  // 4 to 5\n\n  moveNumDown(19);\n  moveNumUp(14);\n  moveNumUp(17);\n  moveNumUp(18);\n  moveNumUp(20);\n  break;\n\ncase 6:  // 5 to 6\n\n  moveNumUp(15);\n  break;\n\ncase 7:  // 6 to 7\n\n  moveNumDown(14);\n  moveNumDown(15);\n  moveNumDown(17);\n  moveNumDown(18);\n  moveNumUp(19);\n  break;\n\ncase 8: // 7 to 8\n\n  moveNumUp(14);\n  moveNumUp(15);\n  moveNumUp(17);\n  moveNumUp(18);\n  break;\n\ncase 9: // 8 to 9\n\n  moveNumDown(15);\n  break;\n\ncase 12: // 2 to 1 for 12 to 01 edge case\n\n  moveNumDown(0);\n  moveNumDown(1);\n  moveNumDown(3);\n  moveNumDown(6);\n  moveNumUp(2);\n  break;\n</code></pre> <p>}</p> <p>hourOne = desired;</p> <p>}</p> <p>void incMinuteTen(int desired){</p> <p>switch(desired){</p> <pre><code>case 1: // 0 to 1\n\n  moveNumDown(7);\n  moveNumDown(8);\n  moveNumDown(10);\n  moveNumDown(11);\n  moveNumDown(13);\n  break;\n\ncase 2: // 1 to 2\n\n  moveNumDown(9);\n  moveNumUp(7);\n  moveNumUp(8);\n  moveNumUp(10);\n  moveNumUp(13);\n  break;\n\ncase 3: // 2 to 3\n\n  moveNumDown(8);\n  moveNumUp(9);\n  break;\n\ncase 4: // 3 to 4\n\n  moveNumDown(7);\n  moveNumDown(13);\n  moveNumUp(11);\n  break;\n\ncase 5: // 4 to 5\n\n  moveNumDown(12);\n  moveNumUp(7);\n  moveNumUp(13);\n  break;\n\ncase 0: // 5 to 0\n\n  moveNumDown(10);\n  moveNumUp(8);\n  moveNumUp(12);\n  break;\n</code></pre> <p>}</p> <p>minuteTen = desired;</p> <p>}</p> <p>void incMinuteOne(int desired){</p> <p>switch(desired){                                                                                            //WORRY about Case 1?????</p> <pre><code>case 1:\n\n  // change 0 to 1\n  moveNumDown(0);\n  moveNumDown(1);\n  moveNumDown(3);\n  moveNumDown(4);\n  moveNumDown(6);\n  break;\n\ncase 2:\n\n  //change 1 to 2 \n  moveNumDown(2);\n  moveNumUp(1);\n  moveNumUp(6);\n  moveNumUp(3);\n  moveNumUp(0);\n  break;\n\ncase 3:\n\n  // change 2 to 3\n  moveNumDown(1);\n  moveNumUp(2);\n  break;\n\ncase 4:\n\n  //change 3 to 4\n  moveNumDown(6);\n  moveNumDown(0);\n  moveNumUp(4);\n  break;\n\ncase 5:\n\n  //change 4 to 5\n  moveNumDown(5);\n  moveNumUp(6);\n  moveNumUp(0);\n  break;\n\ncase 6:\n\n  // change 5 to 6\n  moveNumUp(1);\n  break;\n\ncase 7:\n\n  // change 6 to 7\n  moveNumDown(0);\n  moveNumDown(1);\n  moveNumDown(3);\n  moveNumDown(4);\n  moveNumUp(2);\n  moveNumUp(5);\n  break;\n\ncase 8:\n\n  // change 7 to 8\n  moveNumUp(4);\n  moveNumUp(3);\n  moveNumUp(1);\n  moveNumUp(0);\n  break;\n\ncase 9:\n\n  // change 8 to 9\n  moveNumDown(1);\n  moveNumDown(0);\n  break;\n\ncase 0:\n\n  //change 9 to 0\n  moveNumDown(3);\n  moveNumUp(1);\n  moveNumUp(0);\n  setMinuteTen(minuteTen++);\n  break;\n\n}\n\nminuteOne = desired;\n</code></pre> <p>}</p> <p>// This section is not to be manipulated past testing. It functions as intended and will safely raise and lower bars</p> <p>// Num means its connected to the servo controller // Pin means its directly connected to the servo controller.  void moveNumUp(int servoNum){</p> <p>if (servoNum &gt; SERVO_DRIVER_CAP){</p> <pre><code>for (int pos = SERVO_MIN; pos&lt;=SERVO_MID; pos++){\n\n    driver.setPWM(servoNum, 0, pos);\n    delay(5);\n\n}\n\ndelay(10);\ndriver.setPWM(servoNum,0, SERVO_MID);\n</code></pre> <p>} else {</p> <pre><code>for (int pos = SERVO_MIN; pos&lt;=SERVO_MID; pos++){\n\n  driverTwo.setPWM(servoNum, 0, pos);\n  delay(5);\n\n}\n\ndelay(10);\ndriverTwo.setPWM(servoNum,0, SERVO_MID);\n</code></pre> <p>}</p> <p>}</p> <p>void moveNumDown(int servoNum){</p> <p>if (servoNum &gt; SERVO_DRIVER_CAP){</p> <pre><code>for (int pos = SERVO_MID; pos&gt;=SERVO_MIN; pos--){\n\n  driver.setPWM(servoNum, 0, pos);\n  delay(5);\n\n}\n\ndelay(10);\ndriver.setPWM(servoNum,0, SERVO_MIN);\n</code></pre> <p>} else {</p> <pre><code>for (int pos = SERVO_MID; pos&gt;=SERVO_MIN; pos--){\n\n  driverTwo.setPWM(servoNum, 0, pos);\n  delay(5);\n\n}\n\ndelay(10);\ndriverTwo.setPWM(servoNum,0, SERVO_MIN);\n</code></pre> <p>}</p> <p>}</p> <p>```</p>","tags":["tag1","tag2"]},{"location":"MechClock/mechanicalClock/#results","title":"Results","text":"<p>This project is currently not complete so we have not achieved all of the goals of the project.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/","title":"Useless Box","text":"","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#overview","title":"Overview","text":"<p>Create a project to learn the basics of a pull up switch and motor using Arduino while ensuring the design is simple and replication is easy. If the goal is to view the project components please look at the Bill of Materials under the technical section and download the 3D printing files and the code base.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#contribution","title":"Contribution","text":"<p>This was an individual project which allowed me to work through all aspects of the project from initial conception to testing to final completion.</p>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#technical-details","title":"Technical Details","text":"<p> All length units are in millimeters and angle units are in degrees.</p> Item Name Quantity Price Arduino Uno 1 $27.60 3D print filament 187.74 grams ~$3.20 Servo Futaba S3003 1 $6.25 3 position switch 1 $0.67 Copper wires 1 $3.67 <p>Code Base:</p> <pre><code>#include &lt;Servo.h&gt;\nServo ctrlArm; // create servo object to control a servo\n\n// Hours spent refactoring: .75 \n// Version 1.1\n// Created by Jacob Dirks\n\n// two of twelve ' board limit' reached'\n\nint pos = 0; // variable to control ctrl arm position\nint altCount = 0;\nint shortHeight = 150; // What is this\nint count = 1; // this is what we'll use for the random case generator. Makes it easier to store number\nint caseCount = 5; // easier to update later\nint runCount = 0;\nint moveBox = 3; // stores number 3 for pin 3\nint TState = 0; //variable for storing switch status\nint TStatePrior = TState; // stores previous state\n\nvoid setup() {\n  // put your setup code here, to run once:\n  ctrlArm.attach(13);\n  pinMode(moveBox, INPUT_PULLUP); // sets it as a special kind of input which is how the lever requires it\n\n  ctrlArm.write(pos); // gives it the first desire to go there\n  delay(100);\n  ctrlArm.write(pos); // allows the time to get there or is this what causes the initial open and close\n  delay(50);\n\n}\n\nvoid loop() {\n\n// section to open and move the box\nTState = digitalRead(moveBox); // reads state of switch\n\nif((TState == 1) &amp;&amp; (TStatePrior == 0)) { // changes the arm to replace it\n    if(pos != 170){\n      count = ((int)random(1, 2*caseCount) % caseCount);\n\n      switch(count){\n          case 0: // fast bounces cause angry\n\n              for(runCount=0; runCount&lt;=7; runCount += 1){\n\n                for(pos = 20; pos &lt;=45 ; pos+= 5){\n\n              ctrlArm.write(pos);\n              delay(10); // waits 10ms for the servo to reach the position\n\n              }\n                for(pos=45; pos&gt;=20; pos-=1){\n                  ctrlArm.write(pos);\n                  delay(15);\n                }\n              } \n\n              delay(20);\n\n              closeLidSpeed(15);\n              break;\n          case 2: // just close the lid\n            closeLidSpeed(15);\n            delay(20);\n            break;\n\n          case 3:/* a slow and then come back only to go out and hold it down again */\n\n            closeLidSpeed(25);\n            delay(30);\n            closeLidSpeed(25);\n            delay(180);\n            break;\n\n          case 4: // slow but up down a few times\n            closeLidSpeed(20);\n\n            for(runCount=0; runCount &lt; 2; runCount+= 1){\n\n              for(pos=20; pos&lt;=80; pos+= 2){\n\n                ctrlArm.write(pos);\n                delay(15);\n\n              }\n\n              for(pos=80; pos &gt;=20; pos-= 2){\n\n                ctrlArm.write(pos);\n                delay(15);\n\n              }\n\n            }\n\n            closeLidSpeed(15);\n\n          default:\n\n           closeLidSpeed(30);\n            break;\n        }\n      }\n\n        //here is the common code\n\n      TStatePrior = TState; // stores previous Tstate\n      TState = digitalRead(moveBox); // updates TState\n    } //end if of tstate = 1 and prior = 0\ndelay(250);\n  if((TState == 0) &amp;&amp; (TStatePrior ==1)) {\n\n  if(pos != 20){ // if not at home then return there\n  for (pos = 170; pos &gt;= 20; pos -= 10) { // goes from 170 degrees to 20 degrees \n\n    ctrlArm.write(pos); // tell servo to go to position in variable 'pos'\n    delay(15); // waits 15ms for the servo to reach the position\n\n  }\n  }\n  TState = digitalRead(moveBox);\nTStatePrior = 0;\n\n} else {\n  delay(250);\n  TState = digitalRead(moveBox);\n}\n\n} \n\nvoid closeLidSpeed(int speed){ // a method to simply flip the switch back with a delay choice\n  for (pos = 20; pos&lt;= 170; pos+=10){\n    ctrlArm.write(pos);\n    delay(speed); // wait 15 ms and then move it\n  }\n  ctrlArm.write(170);\n  pos = 170;\n}\n</code></pre>","tags":["tag1","tag2"]},{"location":"UselessBox/uselessBox/#results","title":"Results","text":"<p>I was able to successfully build, test, and improve the useless box. Although there were several complications along the way regarding CAD software, signal reading, and physical manipulations.</p> System/Software Lessons Learned Solidworks Planes on an object, extrusion about an axis, print in place features, and tolerance printing Arduino Importance of simplifying complex sections in code, highlighting reusable parts, and the blessings of commented code <p>Future improvements: Reduce the footprint of the box, optimize port usage versus numbers, and add more reactions for the switch.</p>","tags":["tag1","tag2"]}]}